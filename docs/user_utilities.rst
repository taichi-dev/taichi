User utilities
==============

Taichi provides several development tools that can be used to greatly improve development efficiency. This section aims to provide a detailed description of some commonly used tools, including:

* Logging
* Profiler

Logging
-------

Based on spdlog, Taichi provides a series of APIs for logging. Note that these functions will be called in compile-time but not run-time, if you want to log in run-time, please use ``print()`` instead.

.. Note::

    The current taichi logging API only supports standard output.

.. function:: ti.set_logging_level(level)

    :parameter level: (string) a valid logging level

    - This function is used to set the level of printing logs. Currently, the log levels in taichi are classified from low to high as ``ti.TRACE``, ``ti.DEBUG``, ``ti.INFO``, ``ti.WARN`` and ``ti.ERROR``. These logging levels are essentially strings "trace", "debug", "info", "warn" and "error" respectively.

    - The lower the log level, the more content will be printed out. For example, if you set the print level to ``ti.TRACE``, all logs will be printed; if you set the print level to ``ti.ERROR``, only those log which is generated by ``ti.error()`` will be output.

    - The default logging level is ``ti.INFO``.You can also override the default logging level by setting the environment variable like ``TI_LOG_LEVEL=warn``.

.. function:: ti.info(info)

    :parameter info: (string) logging info

    Print out the input string in green color to stdout, when the logging level is lower or equal to ``ti.INFO``. For example:

.. code-block:: python

    import taichi as ti
    ti.init(arch = ti.cpu)

    ti.set_logging_level(ti.INFO)
    var = ti.var(ti.f32, shape = 1)

    @ti.kernel
    def compute():
        var[0] = 1.0
        ti.info(f"set var[0] = 1.0")

    compute()

.. function:: ti.warn(info)

    :parameter info: (string) logging info

    Print out the input string in yellow color to stdout, when the logging level is lower or equal to ``ti.WARN``.

.. function:: ti.debug(info)

    :parameter info: (string) logging info

    Print out the input string in blue color to stdout, when the logging level is lower or equal to ``ti.DEBUG``.

.. function:: ti.trace(info)

    :parameter info: (string) logging info

    Print out the input string in blue color to stdout, only when the logging level is equal to ``ti.TRACE``.

.. function:: ti.error(info)

    :parameter info: (string) logging info

    This function prints out the input string in red color to stdout in any logging level.

    Note that it crashes the Taichi kernel as well as your Taichi program then throw an ``RuntimeError`` out.

.. Warn::

    The usages of ``ti.trace()``, ``ti.debug()`` and ``ti.warn()`` are all similar to ``ti.info()``.But ``ti.error()`` is different from them. When it is called, the program will be crashed immediately.

    In spite of this, the output of ``ti.error()`` is still ``stdout`` but not ``stderr``.

Here is an example:

.. code-block:: python

    import taichi as ti

    ti.init()
    ti.set_logging_level(ti.ERROR)

    try:
        ti.error("It's a big error! Now exit...")
    except RuntimeError as err:
        print(err)

Profiler
--------

Taichi profiler can help you count the time cost of your program. There are 2 profilers in Taichi available at this moment: ``ScopedProfiler`` and ``ProfilerBase``.

ScopedProfiler
##############

1. ``ScopedProfiler`` evaluates the time spent for each step of the **host tasks** during execution hierarchically.

2. Moreover, this profiler is turned on automatically and no extra work is needed except writing ``ti.core.print_profile_info()`` at the end of your Taichi program. For example:

.. code-block:: python

    ti.init(arch = ti.cpu)
    var = ti.var(ti.f32, shape = 1)

    @ti.kernel
    def compute():
        var[0] = 1.0
        print(f" set var[0] = {var[0]}")

    compute()
    ti.core.print_profile_info()

``ti.core.print_profile_info()`` will output statistics in a hierarchical format, with different colors for different levels.

.. Note::

    ``ScopedProfiler`` is a c++ class inside of Taichi core, so you cannot see it directly in python scope.

    We mention its name here is just to make a distinction with another profiler.

ProfilerBase
############

1. ``ProfilerBase`` records the cost of kernel launches on devices. ``kernel_profiler`` must be set to ``True`` in ``ti.init`` to enable this profiler.

2. When all the computation is finished in your program, call ``ti.kernel_profiler_print()`` to show to profiling result. For example:

.. code-block :: python
    :emphasize-lines: 1, 9

    ti.init(ti.cpu, kernel_profiler = True)
    var = ti.var(ti.f32, shape = 1)

    @ti.kernel
    def compute():
        var[0] = 1.0

    compute()
    ti.kernel_profiler_print()

Its output is like:

::

    [ 22.73%] jit_evaluator_0_kernel_0_serial             min   0.001 ms   avg   0.001 ms   max   0.001 ms   total   0.000 s [      1x]
    [  0.00%] jit_evaluator_1_kernel_1_serial             min   0.000 ms   avg   0.000 ms   max   0.000 ms   total   0.000 s [      1x]
    [ 77.27%] compute_c4_0_kernel_2_serial                min   0.004 ms   avg   0.004 ms   max   0.004 ms   total   0.000 s [      1x]
